### 板书

- 今天要将的内容是AST, 或者说抽象语法树和它在前端(具体来说前端工程化)中的基本应用，起到一个抛砖引玉的作用

    

- AST是Abstract Syntax Tree，即抽象语法树的缩写，是源代码结构的抽象表示，也是编译原理中一个非常基础的内容，不过对于一开始的前端学习者这方面接触的确实不多(比如说我)。虽然日常工作中很多时候都不需要去了解编译器怎么做的，但是有许多的前端开发工具或者库都是基于编译原理去进行构建的。例如..之类的种种，具体的更多应用之后再第三部分去讲。例如前端过程中的typescript/babel还有eslint/webpack以及一些前端的框架和脚手架之类的各种东西都有很多依赖于AST去开发的功能。当然还有js的转译、代码压缩以及各种css的预处理器都是涉及到相关原理的。

    

- 下边是编译原理书中描述的编译型语言的一个编译的过程，我们可以看到

- 而对于JS这样的解释型语言，虽然看起来不需要传统的编译流程，但是实际上以chrome的v8引擎为例，他走的是一个JIT/just in time的实时编译的策略，他的一个基本的流程只有这三部分。

    

- 第一步，词法分析，也叫做扫描scanner。它读取我们的代码，然后把它们按照预定的规则合并成一个个的标识tokens。同时，它会移除空白符，注释，等。最后，整个代码将被分割进一个tokens列表（或者说一维数组）。

- 这边实际上我还省略掉了分号，token的解析过程中实际上也是涉及到了

- 第二步，语法分析，也解析器。它会将词法分析出来的数组转化成树形的表达形式。同时，验证语法，语法如果有错的话，抛出语法错误。

    

- 看了这两个例子，对于AST有一点基本了解了，接下来我们看下AST在Babel中的运用，或者说怎么用babel的一些库去完成一点简单的功能需求

- 宏观来说，它分3个阶段运行代码：解析（parsing），转译（transforming），生成（generation）。我们可以给babel 一些javascript代码，它修改代码然后生成新的代码返回。那它是怎样修改代码的呢？没错！它创建了AST，遍历树，修改tokens，最后从AST中生成新的代码。

- 解析(parse)：将代码字符串解析成抽象语法树。

  转换(transform)：对抽象语法树进行转换操作。

  生成(generate): 根据变换后的抽象语法树再生成代码字符串。

- 我们只要关心，就是AST转译这一步了。

- 使用一些库，来快速利用AST对js进行快速修改开发的目的

- 今天这个例子就是给console.log加上一些简单的上下文信息

- 我们常常给工程里边打console, 但是对于大项目/特别是涉及到多个子项目多人开发的项目就很难一下子定位到自己打的console位置。

- /babel-plugin-transform-remove-console

- 我们最后做一下总结：

  - 我们想要把这串代码最终转化成带上方法名的样式
  - 先去匹配CallExpression
  - 然后通过匹配 调用类型/函数的主体/函数的名称 去找 console.log 
  - 找到了这个函数的节点皆可以去寻找函数的 caller/调用者 获取他的信息 update当前的节点
  - 当然，如果我们要去做这样一个代码转化的插件要考虑的东西很多
    - 像函数声明有很多方式 可能是箭头函数 也可能是匿名函数
    - 以及函数的调用者 他可能是在 函数里也可能在class里
  - 最后，怎么把它用到你的工程中呢，  扔到.babelrc或者transform的时候作为参数就可以了



- 具体到前端工程化，面临的问题是如何提高编码->测试->维护阶段的生产效率以及如何提高前端应用质量。

- 工程化

  - 模块化：将一个文件拆分成多个相互依赖的文件，最后进行统一的打包和加载，这样能够很好的保证高效的多人协作。
    - JS 模块化：CommonJS、AMD、CMD 以及 ES6 Module。/Ts模块
    - CSS 模块化：Sass、Less、Stylus、BEM、CSS Modules 等。其中预处理器和 BEM 都会有的一个问题就是样式覆盖。而 CSS Modules 则是通过 JS 来管理依赖，最大化的结合了 JS 模块化和 CSS 生态，比如 Vue 中的 style scoped。
    - 资源模块化：任何资源都能以模块的形式进行加载，目前大部分项目中的文件、CSS、图片等都能直接通过 JS 做统一的依赖关系处理。
  - 组件化：不同于模块化，模块化是对文件、对代码和资源拆分，而组件化则是对 UI 层面的拆分。
    - 通常，我们会需要对页面进行拆分，将其拆分成一个一个的零件，然后分别去实现这一个个零件，最后再进行组装。
    - 在我们的实际业务开发中，对于组件的拆分我们需要做不同程度的考量，其中主要包括细粒度和通用性这两块的考虑。
    - 对于业务组件，你更多需要考量的是针对你负责业务线的一个适用度，即你设计的业务组件是否成为你当前业务的 “通用” 组件，比如我之前分析过的权限校验组件，它就是一个典型的业务组件。
  - 规范化：正所谓无规矩不成方圆，一些好的规范则能很好的帮助我们对项目进行良好的开发管理。
    - 项目目录结构
    - 文件命名规范
    - * 编码规范：对于编码这块的约束，一般我们都会采用一些强制措施，比如 ESLint、StyleLint 等。
    - 联调规范
    - * 样式管理规范：目前流行的样式管理有 BEM、Sass、Less、Stylus、CSS Modules 等方式。
    - git flow 工作流：其中包含分支命名规范、代码合并规范等。
    - 定期 code review
  - 自动化：从最早先的 grunt、gulp 等，再到目前的 webpack、parcel。这些自动化工具在自动化合并、构建、打包都能为我们节省很多工作。而这些前端自动化其中的一部分，前端自动化还包含了持续集成、自动化测试等方方面面。

- 模块和组件的区别 模块是针对复杂系统功能的分治策略，同时利用资源管理策略进行项目的构建

- 简单讲，module侧重的是对属性的封装，重心是在设计和开发阶段，不关注runtime的逻辑。module是一个白盒；而component是一个可以独立部署的软件单元，面向的是runtime，侧重于产品的功能性。component是一个黑盒，内部的逻辑是不可见的。

  用通俗的话讲，模块可以理解为零件，比如轮胎上的螺丝钉；而组件则是轮胎，是具备某项完整功能的一个整体。具体到前端领域，一个button是一个模块，一个包括多个button的nav是一个组件。

- 构建的核心是资源管理。

- 应用
  - babel: 实现 JS 编译，转换过程是 AST 的转换
  - 自动代码重构工具，以及神器JSCodeshift/CodeModes。
  - ESlint: 代码错误或风格的检查，发现一些潜在的错误
  - IDE 的错误提示、格式化、高亮、自动补全等 
  - 代码打包工具 webpack
  - UglifyJS 压缩代码
  - taro/mpvue
  - 在JavaScript内实现一个JavaScript解释器
  - 将代码转化为svg图像



- 刚才描述的这些AST在前端中的应用，不只有devdependence（开发过程中的依赖）也有不少的功能性依赖，在开发面向技术人员的产品过程中，不仅能够提高开发的效率，也能提高不少技术向功能的组件质量。从单纯的堆砌demo到结合实例和系统需求去完成一整个工程化的软件项目，今天讲的这个算是简单的抛砖引玉，其他有趣的例子和相关的文章之后我都尽量总结到学城里





### Extra

[13 个例子快速了解JS抽象语法树](https://zhuanlan.zhihu.com/p/40102300)

什么是AST（抽象语法树）？

> It is a hierarchical program representation that presents source code structure according to the grammar of a programming language, each AST node corresponds to an item of a source code.

What

How

Why

When/Where



## 前端工程化

- 模块化
- 组件化
- 规范化
- 自动化

对应前端项目的

- 编码
- 测试
- 部署/持续集成



[javascript-ast](https://link.zhihu.com/?target=http%3A//resources.jointjs.com/demos/javascript-ast)

ast-explorer

[AST Explorer](https://astexplorer.net/)